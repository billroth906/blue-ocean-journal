---
layout: post
title: "Getting Hooked"
date: 2021-09-13 09:00:00 -0400
categories: blueOcean
---
### React Hooks or Not
As our group got started on coding our stock-app project this week, we had the ambitious idea of incorporating React hooks as best as possible, given that none of us felt well exposed to this next horizon of React functionality. I spent some time wading through the [React documentation](https://reactjs.org/docs/hooks-intro.html) and watching the introduction video/demonstration from ReactConk 2018. So I went full bore on hooks as I got the leaderboard list functionality rolled out. By the end of the week, I started to scratch my head over the fact that my add/subtract friend button/icons did not seem to be updating as state was updating. At first I blamed in on the infinite scroll implementation, but the further I digged the more I saw that even though state was updating, the list elements were not changing. Turns out that any child components or functions using state never get updated state, only the state that existed when they were first defined. In React's words, "Any function inside a component, including event handlers and effects, “sees” the props and state from the render it was created in."(https://reactjs.org/docs/hooks-faq.html#why-am-i-seeing-stale-props-or-state-inside-my-function) There are ways around this. The React docs suggest using refs, and one of my group members suggested trying using contexts. But clearly, both of these solutions (and anything else I found on Stack Overflow) were much more convoluted (and potentially more unstable) than just converting these hooks to the old-fashioned class business. So that is what came to pass.

### Infinite Scroll
Another major endeavor this week was focused around infinite scroll. After a bit of trial and digging, I found the react-infinite-scroll-component package to be helpful (https://www.npmjs.com/package/react-infinite-scroll-component), especially because as an added bonus that package includes a pull down to refresh feature. The setup was not overly straightforward though, as the documentation is quite ambiguous in many places. Eventually realized that a substantial issue of the package was that it requires an active scrolling event to kick in on its own, meaning that if the list was less than the container length, the component will not load anything. This was worked around by adding an effect to the hook that queryed upon every change to the list as to whether it was filling the div, and if not calling for more data if the last response from the server was not an empty array. Eventually, when I transitioned to classes, I shifted the event over to ComponentDidMount and ComponentDidUpdate.

### PG Connection
Made an interesting discovery upon dialogue with my group this week that everyone else was using pg to connect to a Postgres database rather than pg-promise. I had gone down the pg-promise road a couple months ago, arbitrarily just following the ExpressJS documentation, which recommends pg-promise. It seems that pg-promise derived at ome point from pg. The developer of pg-promise made a strong argument for why pg-promise uses the older form of pooling from pg, as by his argument, pg-promise is more capable of reconnecting to a VPS style database after a disconnection (https://stackoverflow.com/questions/43250582/connection-pool-using-pg-promise). I was hoping that the syntax of pg would be similar to pg-promise, but after delving into pg's docs a bit more it does not seem so. Thus I need to work now on transforming my queries from pg-promise to pg as our group decided to go forward with pg given its apparently wider usage.